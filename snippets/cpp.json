{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"if": {
		"prefix": "if",
		"body": "if (${1:/* condition */})"
	},

	"else": {
		"prefix": "else",
		"body": "else"
	},

	"else if": {
		"prefix": "else if",
		"body": "else if (${1:/* condition */})"
	},

	"while": {
		"prefix": "while",
		"body": "while (${1:/* condition */})"
	},

	"do while": {
		"prefix": "do",
		"body": [
			"do",
			"{$0} while (${1:/* condition */});"
		]
	},

	"for loop": {
		"prefix": "for",
		"body": "for (${1:auto} ${2:i} = ${3:0}; $2 < ${4:n}; ++ $2)"
	},

	"for loop with iterator": {
		"prefix": "for",
		"body": "for (auto ${1:ite} = ${2:v}.begin (); $1 < $2.end (); ++ $1)"
	},

	"range-based for loop": {
		"prefix": "for",
		"body": "for (auto && ${1:elem} : ${2:v})"
	},

	"rep": {
		"prefix": "rep",
		"body": "rep (${1:i}, ${2:n})"
	},

	"switch": {
		"prefix": "switch",
		"body": [
			"switch (${1:x})",
			"{$0",
			"default:",
			"}"
		]
	},

	"static": {
		"prefix": "static",
		"body": "static"
	},

	"auto": {
		"prefix": "auto",
		"body": "auto"
	},

	"structured binding": {
		"prefix": "auto",
		"body": "auto && [${1:}] = ${2:/* tuple or array */};"
	},

	"void": {
		"prefix": "void",
		"body": "void"
	},

	"false": {
		"prefix": "false",
		"body": "false"
	},

	"true": {
		"prefix": "true",
		"body": "true"
	},

	"nullptr": {
		"prefix": "nullptr",
		"body": "nullptr"
	},

	"const": {
		"prefix": "const",
		"body": "const"
	},

	"volatile": {
		"prefix": "volatile",
		"body": "volatile"
	},

	"mutable": {
		"prefix": "mutable",
		"body": "mutable"
	},

	"constexpr": {
		"prefix": "constexpr",
		"body": "constexpr"
	},

	"explicit": {
		"prefix": "explicit",
		"body": "explicit"
	},

	"inline": {
		"prefix": "inline",
		"body": "inline"
	},

	"operator": {
		"prefix": "operator",
		"body": "operator ${1:+} (${2:})${3: noexcept} -> decltype(auto)"
	},

	"private": {
		"prefix": "private",
		"body": "private:"
	},

	"protected": {
		"prefix": "protected",
		"body": "protected:"
	},

	"public": {
		"prefix": "public",
		"body": "public:"
	},

	"decltype": {
		"prefix": "decltype",
		"body": "decltype (${1:/* expression */})"
	},

	"noexcept": {
		"prefix": "noexcept",
		"body": "noexcept"
	},

	"noexcept expression": {
		"prefix": "noexcept",
		"body": "noexcept (${1:/* expression */})"
	},

	"break": {
		"prefix": "break",
		"body": "break;"
	},

	"case": {
		"prefix": "case",
		"body": "case ${1:/* integral constant */}:"
	},

	"continue": {
		"prefix": "continue",
		"body": "continue;"
	},

	"goto": {
		"prefix": "goto",
		"body": "goto ${1:/* label */};"
	},

	"default": {
		"prefix": "default",
		"body": "default"
	},

	"delete": {
		"prefix": "delete",
		"body": "delete"
	},

	"new": {
		"prefix": "new",
		"body": "new"
	},

	"static_assert": {
		"prefix": "static_assert",
		"body": "static_assert (${1:/* condition */});"
	},

	"static_cast": {
		"prefix": "static_cast",
		"body": "static_cast <${1:/* type */}> (${2:/* expression */})"
	},

	"throw": {
		"prefix": "throw",
		"body": "throw ${1:/* expression */};"
	},

	"return": {
		"prefix": "return",
		"body": "return ${1:res};"
	},

	"namespace": {
		"prefix": "namespace",
		"body": "namespace ${1:detail} {$0} // namespace $1"
	},

	"template": {
		"prefix": "template",
		"body": "template <$0>"
	},

	"typename": {
		"prefix": "typename",
		"body": "typename ${1:T}"
	},

	"variadic template": {
		"prefix": "typename",
		"body": "typename ... ${1:Ts}"
	},

	"function": {
		"prefix": "function",
		"body": [
			"inline${2: constexpr} auto ${1:f} ()${3: noexcept}",
			"{",
			"\t$0",
			"}"
		]
	},

	"lambda": {
		"prefix": "lambda",
		"body": [
			"[&] (auto && ${1:x}) {",
			"\treturn $1$0;",
			"}"
		]
	},

	"try - catch": {
		"prefix": "try",
		"body": [
			"try",
			"{",
			"\t$0",
			"}",
			"catch (const ${1:exception} & ${2:e})",
			"{",
			"\tcerr << $2.what () << endl;",
			"}"
		]
	},

	"main": {
		"prefix": "main",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"auto main () -> int",
			"{",
			"\tcin.tie (nullptr);",
			"\tios::sync_with_stdio (false);",
			"\t$0",
			"}",
			""
		]
	},

	"cin": {
		"prefix": "cin",
		"body": "cin >> ${1:n};"
	},

	"cout": {
		"prefix": "cout",
		"body": "cout << ${1:ans} << endl;"
	},

	"cout bool": {
		"prefix": "cout",
		"body": "cout << (${1:ans} ? \"${2:true}\" : \"${3:false}\") << endl;"
	},

	"iterator pair": {
		"prefix": "ALL",
		"body": [
			"${1:v}.begin (), $1.end ()"
		],
		"description": "iterator pair"
	},

	"input with istream_iterator": {
		"prefix": "istream_iterator",
		"body": "copy_n (istream_iterator <decay_t <decltype ($1.front ())>> (cin), ${2:n}, back_inserter (${1:v}));"
	},

	"iterator pair of istream": {
		"prefix": "istreambuf_iterator",
		"body": "(istreambuf_iterator <char> (cin)), istreambuf_iterator <char> ()"
	},

	"output with ostream_iterator": {
		"prefix": "ostream_iterator",
		"body": [
			"copy (${1:v}.begin (), $1.end (), ostream_iterator <decay_t <decltype ($1.front ())>> (${2:cout}, \" \"));",
			"$2 << endl;"
		]
	},

	"unique": {
		"prefix": "unique",
		"body": "${1:v}.erase (unique ($1.begin (), $1.end ()), $1.end ());"
	},

	"define rep": {
		"prefix": "#define rep",
		"body": "#define rep(i,n) for (decay_t <decltype (n)> i = 0, i ## __len = (n); i < i ## __len; ++ i)"
	},

	"ifdef": {
		"prefix": "#ifdef",
		"body": [
			"#ifdef ${1:LOCAL}",
			"$0",
			"#endif",
			""
		]
	},

	"size_t": {
		"prefix": "size_t",
		"body": "size_t"
	},

	"int64_t": {
		"prefix": "int64_t",
		"body": "int64_t"
	},

	"unique_ptr": {
		"prefix": "unique_ptr",
		"body": "unique_ptr"
	},

	"1e9+7": {
		"prefix": "1e9+7",
		"body": "static_cast <int64_t> (1000000007)"
	},

}